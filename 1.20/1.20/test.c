#include <stdio.h>
//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;
////假设p 的值为0x100000。 如下表表达式的值分别为多少？
////已知，结构体Test类型的变量大小是20个字节
////20--00010100
////    0x100000
////        1000
////指针加+1到底加几呢？
////指针加1跳过多少取决于指针类型
////整数加一就是加1
//int main()
//{
//	p = (struct Test*)0x100000;
//	printf("%p\n", p + 0x1);
//	//p+1取决于指针类型，这个指针是结构体类型大小为20，所以加1就跳过一个结构体大小20
//	//16进制的20为14
//	//0x100014
//	printf("%p\n", (unsigned long)p + 0x1);
//	//这里将p强制类型转换成无符号长整形，也就变成了整数了，整数加1就是简单的加减运算
//	//0x100001
//	printf("%p\n", (unsigned int*)p + 0x1);
//	//这里将p强制类型转换成int*类型，所以p+1跳过一个整形大小，也就是4个字节
//	//0x100004
//	return 0;
//}
//int main()
//{
//    int a[4] = { 1, 2, 3, 4 };
//    int* ptr1 = (int*)(&a + 1);
//    //&a取出的是整个数组地址，+1跳过整个数组大小，然后又被强制转换成int*类型
//    int* ptr2 = (int*)((int)a + 1);
//    //a表示首元素地址，强制类型转换成整形，这个地址+1，就是整数+1，然后又被强制转换成int*类型
//    printf("%x,%x", ptr1[-1], *ptr2);
//    //ptr1[-1]可以这样表示-->   *(ptr-1)
//    //对ptr2这个指针解引用，能访问多大空间呢？
//    return 0;
//}
//#include <stdio.h>
//int main()
//{
//    int a[3][2] = { (0, 1), (2, 3), (4, 5) };
//    //注意这个不是将（0，1），（2，3），（4，5）放进数组，括号里是个逗号表达式，最终结果应该是{1，3，5}；
//    //所以这个二维数组放的是1，3，5，0，0，0
//    int* p;
//    p = a[0];
//    //a[0]表示数组第一行的数组名，没有单独放进sizeof中，也没有&，所以表示首元素地址，放进p里
//    printf("%d", p[0]);
//    //p[0]表示*(p+0),就是第一个元素 1
//    return 0;
//}
//int main()
//{
//    int a[5][5];
//    int(*p)[4];
//    p = a;
//    printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//    return 0;
//}
////100000000000000000000000000000100原码
////111111111111111111111111111111011反码
////111111111111111111111111111111100补码
//int main()
//{
//    int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
//    int* ptr1 = (int*)(&aa + 1);
//    int* ptr2 = (int*)(*(aa + 1));
//    printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
//    return 0;
//}
//#include <stdio.h>
int main()
{
	char* a[] = { "work","at","alibaba" };
	char** pa = a;
	pa++;
	printf("%s\n", *pa);
	return 0;
}